"""Define the OctopilotSessionWindow

This file shoud be used to lay out the connections between the Dispatcher
and the various plotting widgets, by instantiating them and by laying out
the way they are started and updated by threads and timers.

The OctopilotSessionWindow
* Instantiates and contains the Dispatcher to control the task
* Instantiates each of the individual plotting widgets and lays them out
* Starts QTimer to update the Dispatcher
* Instantiates a start button which will be connected to the start method
  of each individual widget

The plotting widgets are defined in plotting.py. They get the data they
need directly from the Dispatcher.
"""

import sys
import zmq
import numpy as np
import time
import os
import json
import logging

# Qt imports
from PyQt5 import QtWidgets
from PyQt5.QtWidgets import QAction, QWidget, QVBoxLayout, QHBoxLayout, QPushButton
from PyQt5.QtWidgets import QApplication, QMainWindow, QWidget
from PyQt5.QtCore import QObject, pyqtSignal, QThread, QTimer

# From this module
from . import plotting
from . import controllers
from ..shared.logtools import NonRepetitiveLogger


import traceback

class OctopilotSessionWindow(QtWidgets.QMainWindow):
    """Main window of the GUI that arranges all the widgets.
    
    Here we make objects of all the different elements of the GUI and arrange 
    the widgets. We also connect the signals defined earlier to slots defined 
    in other classes to make them be able to share information.
    
    Finally, sys.excepthook is set to self._exception_hook, so that any
    errors in threads will be caught. All we do when that happens is set
    the background red, so that the user has some clue that something bad
    happened.
    
    Methods
    -------
    __init__ : Initalizes
    closeEvent : Called on close, and tells each worker to exit
    """
    def __init__(self, box_params, task_params, mouse_params, sandbox_path, 
        timer_dispatcher_period_ms=50):
        """Initialize a new OctopilotSessionWindow
        
        Arguments
        ---------
        box_params, task_params, mouse_params : dict
            These are typically generated by 
            load_params.load_{box|task|mouse}_params
        
        sandbox_path : path to a directory that exists
            All files will be placed here

        All of the arguments are passed to self.dispatcher, which is a 
        controllers.Dispatcher that controls the entire task. 
        
        This object:
        * Starts self.timer_dispatcher, which calls 
          `self.dispatcher.update` every `timer_dispatcher_period_ms` ms, 
          which is what keeps the task going.
        
        * Lays out an ArenaWidget and a PokePlotWidget, which have
          their own timers, and get their data by inspecting `self.dispatcher`.
        
        * Sets up start and stop buttons. The start button is connected
          to `self.dispatcher.start_session` and the start_plot of the 
          plotting widgets. 
          The stop button is connected to `self.dispatcher.stop_session` and
          the stop_plot of the plotting widgets.
        """
        ## Superclass QMainWindow init
        super().__init__()


        ## Init logger
        self.logger = NonRepetitiveLogger("test")
        sh = logging.StreamHandler()
        sh.setFormatter(logging.Formatter('[%(levelname)s] - %(message)s'))
        self.logger.addHandler(sh)
        self.logger.setLevel(logging.DEBUG)
        
        
        ## This sets up self._exception_hook to handle any unexpected errors
        self._set_up_exception_handling()
        
        
        ## Create the Dispatcher that will run the task
        self.dispatcher = controllers.Dispatcher(
            box_params=box_params, 
            task_params=task_params, 
            mouse_params=mouse_params, 
            sandbox_path=sandbox_path,
            )

        
        ## Create a timer to update the Dispatcher
        self.timer_dispatcher = QTimer(self)
        
        # Any error that happens in dispatcher.update will just crash the
        # timer thread, not the main thread. When this happens, 
        # self._exception_hook is called and sets self.exception_occured.
        # self._check_if_error_occurred will then set the background to red.
        self.timer_dispatcher.timeout.connect(self._check_if_error_occured)
        self.timer_dispatcher.timeout.connect(self.dispatcher.update)


        ## Set up the graphical objects
        # Instantiate a ArenaWidget to show the ports
        self.arena_widget = plotting.ArenaWidget(self.dispatcher)
        
        # Initializing PokePlotWidget to show the pokes
        self.poke_plot_widget = plotting.PokePlotWidget(self.dispatcher)


        ## Creating container widgets for each component 
        # These containers determine size and arrangment of widgets
        arena_widget_container = QWidget()
        arena_widget_container.setFixedWidth(200)  
        arena_widget_container.setLayout(QVBoxLayout())
        arena_widget_container.layout().addWidget(self.arena_widget)

        # Create self.start_button and connect it to self.start_sequence
        self.set_up_start_button()
        
        # Create self.start_button and connect it to self.stop_sqeuence
        # and to self.save_results_to_csv
        self.set_up_stop_button()
        
        # Creating vertical layout for start and stop buttons
        start_stop_layout = QVBoxLayout()
        start_stop_layout.addWidget(self.start_button)
        start_stop_layout.addWidget(self.stop_button)        


        ## Create a layout for all containers
        container_widget = QWidget(self)
        
        # Horizontal layout because it will contain three things side by side
        container_layout = QtWidgets.QHBoxLayout(container_widget)
        
        # Add config_list_container, arena_widget_container, and poke_plot_widget
        # poke_plot_widget is handled separately because we are not creating a container
        # for it. This means that its width and height will both change when resizing
        # the main window. it does not have a fixed width like the other widgets
        container_layout.addWidget(arena_widget_container)
        container_layout.addWidget(self.poke_plot_widget)
        container_layout.addLayout(start_stop_layout)
        
        # Set this one as the central widget
        self.setCentralWidget(container_widget)

        
        ## Set the size and title of the main window
        # Title
        self.setWindowTitle(
            f'Octopilot: box={box_params['name']} '
            f'task={task_params['name']} '
            f'mouse={mouse_params['name']}')
        
        # Size in pixels (can be used to modify the size of window)
        self.resize(1200, 200)
        self.move(700, box_params['ypos_of_gui'])
        
        # Show it
        self.show()

        
        ## Connecting signals to the respective slots/methods 
        # Wait till after the OctopilotSessionWindow is fully initialized
        self.timer_dispatcher.start(timer_dispatcher_period_ms)

    def _set_up_exception_handling(self):
        self.exception_occurred = False 
        
        # this registers the exception_hook() function as hook
        sys.excepthook = self._exception_hook

    def _exception_hook(self, exc_type, exc_value, exc_traceback):
        """Function handling uncaught exceptions.
        
        It is triggered each time an uncaught exception occurs. 
        # https://timlehr.com/2018/01/python-exception-hooks-with-qt-message-box/
        """
        if issubclass(exc_type, KeyboardInterrupt):
            # ignore keyboard interrupt to support console applications
            sys.__excepthook__(exc_type, exc_value, exc_traceback)
        
        else:
            # Flag that an error has occured
            self.exception_occurred = True
            
            # Get the exc_info
            exc_info = (exc_type, exc_value, exc_traceback)
            
            # Form a log message
            log_msg = '\n'.join([
                ''.join(traceback.format_tb(exc_traceback)),
                '{0}: {1}'.format(exc_type.__name__, exc_value),
                ])
            
            # Log it
            self.logger.error(
                "Uncaught exception:\n {0}".format(log_msg))

    def _check_if_error_occured(self):
        """Called every time a dispatcher update is called
        
        Checks self.exception_occurred, which is set by self._exception_hook
        after any uncaught exception. If it is True, set background color to
        red. 
        """
        if self.exception_occurred:
            self.setStyleSheet("background-color: red;") 

    def set_up_start_button(self):
        """Create a start button and connect to self.start_sequence"""
        # Create button
        self.start_button = QPushButton("Start Session")
        
        # Set style
        self.start_button.setStyleSheet(
            "background-color : green; color: white;") 

        # Start the dispatcher and the updates
        # TODO: Handle the case where the dispatcher doesn't actually start
        # because it's not ready
        self.start_button.clicked.connect(self.dispatcher.start_session)
        self.start_button.clicked.connect(self.poke_plot_widget.start_plot)
        self.start_button.clicked.connect(self.arena_widget.start)

    def set_up_stop_button(self):
        """Create a start button and connect to self.start_sequence"""
        # Create button
        self.stop_button = QPushButton("Stop Session")
        
        # Set style
        self.start_button.setStyleSheet(
            "background-color : green; color: white;") 
        
        # Stop the dispatcher and the updates
        self.stop_button.clicked.connect(self.dispatcher.stop_session)
        self.stop_button.clicked.connect(self.poke_plot_widget.stop_plot)

    def closeEvent(self, event):
        """Executes when the window is closed
        
        Send 'exit' signal to all IP addresses bound to the GUI
        """
        # Iterate through identities and send 'exit' message
        self.timer_dispatcher.stop()
        self.dispatcher.stop_session()
        event.accept()